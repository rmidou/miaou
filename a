t_node *createNode()
{
	t_node *newNode;

	newNode = (t_node *)malloc(sizeof(t_node));
	if (newNode == NULL)
	{
		printf("Erreur d'allocation de mémoire\n");
		exit(EXIT_FAILURE);
	}
	newNode->line = '\0';
	newNode->type = 0;
	newNode->child_1 = NULL;
	newNode->child_2 = NULL;
	newNode->parent = NULL;
	return (newNode);
}

void freeTree(t_node *root)
{
	if (root == NULL)
		return;
	freeTree(root->child_1);
	freeTree(root->child_2);
	free(root);
}

void printTreePreorder(t_node *root)
{
	if (root != NULL && root->child_1 != NULL)
	{
		printf("{%s} child_1 = %s   child_2 = %s\n", root->line, root->child_1->line, root->child_2->line);
		printTreePreorder(root->child_1);
		printTreePreorder(root->child_2);
	}
}

t_node	*create_parent(t_node *child)
{
	child->parent = createNode();
	child->parent->child_1 = child;
	return (child->parent);
}
t_node	*or(char *cmd2, t_node *root, int *i, char * str)
{
	t_node		*temp;
	int			quotes;

	temp = root->child_2;
	root->child_2 = createNode();
	root->child_2->line = cmd2;
	root->child_2->parent = root;
	root->child_2->child_1 = temp;
	root->child_2->child_1->parent = root->child_2;
	root = add_nodes(root->child_2, str, *i + 2);
	root = root->parent;
	(*i) += 2;
	quotes = 0;
	while (str[*i + 1])
	{
		if (quotes != 1 && ((str[*i] == '&' && str[*i + 1] == '&') || (str[*i] == '|'
			&& str[*i + 1] == '|')))
			break;
		if (str[*i] == '"' && quotes == 0)
			quotes = 1;
		else if (str[*i] == '"' && quotes == 1)
			quotes = 0;
		(*i)++;
	}
	return(root);
}

t_node	*create_node(char *cmd)
{
	t_node *node;

	node = createNode();
	node->line = cmd;
	return (node);
}

char	*parse_command(char *str, int *i)
{
	char	*cmd;
	int		quotes;

	cmd = NULL;
	quotes = 0;
	while (str[*i + 1])
	{
		if (str[*i] == '(')
		{
			
		}
		if (quotes != 1 && ((str[*i] == '&' && str[*i + 1] == '&') || (str[*i] == '|' && str[*i + 1] == '|')))
			break;
		if (str[*i] == '"' && quotes == 0)
			quotes = 1;
		else if (str[*i] == '"' && quotes == 1)
			quotes = 0;
		if (cmd != NULL || !ft_isspace(str[*i]))
			cmd = ft_straddchr(cmd, str[*i]);
		(*i)++;
    }
	if ((str[*i] != '|' && str[*i] != '&') && !ft_isspace(str[*i]))
		cmd = ft_straddchr(cmd, str[*i]);
	return (cmd);
}

void	add_child(t_node *root, char *cmd1)
{
	if (root->child_1 == NULL && cmd1 != NULL)
	{
		root->child_1 = createNode();
		root->child_1->line = cmd1;
		root->child_1->parent = root;
	}
	else if (cmd1 != NULL)
	{
		root->child_2 = createNode();
		root->child_2->line = cmd1;
		root->child_2->parent = root;
	}
}

t_node	*manage_parent(char	*cmd1, t_node *root, char *str, int i)
{
	if (root->line == NULL)
		root->line = cmd1;
	else
	{
		if (root->child_1 && root->child_2)
		{
			//printf("%c%c == ||  ,   %c%c == &&", root->line[0], root->line[1],str[i], str[i + 1]);
			if((root->line[0] == '|' && root->line[1] == '|') && (str[i] == '&' && str[i + 1] == '&'))
				root = or(cmd1, root, &i, str);
			else
			{
				root = create_parent(root);
				root->line = cmd1;
			}
		}
	}
	return (root);
}

t_node	*add_nodes(t_node *root, char *str, int i)
{
	char		*cmd1;

	cmd1 = parse_command(str, &i);
	// if (root->child_1 && root->child_2)
	// 	root = create_parent(root);
	add_child(root, cmd1);
	cmd1 = NULL;
	if (str[i] && str[i + 1])
	{
		cmd1 = ft_straddchr(cmd1, str[i]);
		cmd1 = ft_straddchr(cmd1, str[i + 1]);
		root = manage_parent(cmd1, root, str, i);
		i += 2;
	}
	if (str[i] && str[i + 1])
		return (add_nodes(root, str, i));
	else
		return (root);
}

int main(int ac, char *av)
{
	t_node	*root;

	root = createNode();
	root = add_nodes(root, "cmd1 miaou && cmd2 && mehhh || cmd3 apagnan && cmd4", 0);
	ft_printf("Parcours préfixe de l'arbre binaire:\n");
	printTreePreorder(root);
	printf("\n");
	freeTree(root);
	return 0;
}
